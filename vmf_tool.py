##TODO:
#################################### write to file (export)
# setattr version & speed compare
# -- for key in self.dict.keys():
# --    setattr(self, key, self.dict[key])
# -- del self.dict
# compare named tuple performance
# python 3.7 (f-strings & dataclasses)
# entitiy I/O visualisation (html? html based editor?)
# .js version for web-editor
# -- does js have a faster importer? (builtins)
# .vmf diff (utilise difflib)
# -- export to vmf
# --- two visgroups, one for each map
# --- only diffent solids / entities
# locate overlapping brushes (doubles most important)

##VMT_TOOL
# This almost works with .vmt but headers are occasionally in quotes
# Since .vmf is usually generated by a computer it can be more strict
# However with .vmt there are both quoted & non-quoted keys & classnames
# Tab-depth may be interchanged with spaces [line.replace('    ', '\t')]
# Water makes for the most complex .vmt(s) AFAIK

##QUESTIONS:
# can this code be used for .bsp entitiy lumps?
# -- are bsp entities ever multi-dimensional?

def pluralise(word):
    if word.endswith('f'): # self -> selves
        return word[:-1] + 'ves'
    elif word.endswith('y'): # body -> bodies
        return word[:-1] + 'ies'
    else:
        return word + 's'

def singularise(word):
    if word.endswith('ves'): # self <- selves
        return word[:-3] + 'f'
    elif word.endswith('ies'): # body <- bodies
        return word[:-3] + 's'
    elif word.endswith('s'):
        return word[:-1]
    else: # assume word is already singular
        return word

class scope:
    """Handles a string used to index a multi-dimensional dictionary, correctly reducing nested lists of dictionaries"""
    def __init__(self, strings=[]):
        self.strings = strings
                           
    def __len__(self):
        """ returns depth, ignoring plural indexes"""
        return len(filter(lambda x: isinstance(x, str), self.strings))

    def __repr__(self):
        scope_string = ''
        for string in self.strings:
            if isinstance(string, str):
                scope_string += "['" + string + "']"
            elif isinstance(string, int):
                scope_string += "[" + str(string) + "]"
        return scope_string

    def add(self, new):
        self.strings.append(new)

    def reduce(self, count):
        for i in range(count):
            try:
                if isinstance(self.strings[-1], int):
                    self.strings = self.strings[:-2]
                else:
                    self.strings = self.strings[:-1]
            except:
                break


class vmf:
    def __init__(self, file):
        self.filename = file.name
        self.dict = {}
        current_scope = scope()
        line_no = 1
        tab_depth = -1
        for line in file.readlines():
##            print(line_no, line)
            line_no +=1
##            if line_no > 420:
##                raise RuntimeError()
            new_tab_depth = line.count('\t')
            line = line.lstrip('\t')
            line = line.rstrip('\n')
            if line == '' or line == '{' or line == '}':
                pass
##          elif line == '}':
##              print('*** DOWNSHIFTING ***')
##              print(current_scope, '>>>', end=' ')
##              current_scope.reduce(tab_depth - new_tab_depth + 1)
##              print(current_scope)
            elif '"' not in line:
                if new_tab_depth == 0:
##                    print('*** RESETTING SCOPE ***')
                    current_scope = scope([]) # blank scope() doesn't work, but why?
                if new_tab_depth <= tab_depth:
##                    print('*** DOWNSHIFTING ***')
##                    print(current_scope, '>>>', end=' ')
                    current_scope.reduce(tab_depth - new_tab_depth + 1)
##                    print(current_scope)
                current_keys = eval('self.dict{}.keys()'.format(current_scope))
                lines = pluralise(line)
                if line in current_keys:
##                    print('*** PLURAL SHIFT ***')
##                    print("{}['{}'] = [{}['{}']]".format(current_scope, lines, current_scope, line))
                    exec('self.dict{}[lines] = [self.dict{}[line]]'.format(current_scope, current_scope))
##                    print('self.dict{}.pop({})'.format(current_scope, line))
                    exec('self.dict{}.pop(line)'.format(current_scope))
##                    print("{}['{}'].append(dict())".format(current_scope, lines))
                    exec('self.dict{}[lines].append(dict())'.format(current_scope))
                    current_scope = scope([*current_scope.strings, lines, 1])
##                    print(current_scope)
##                    print(current_keys)
                elif lines in current_keys:
##                    print('*** PLURAL APPEND ***')
                    current_scope.add(lines)
##                    print("{}.append(dict())".format(current_scope))
                    exec("self.dict{}.append(dict())".format(current_scope))
                    current_scope.add(len(eval('self.dict{}'.format(current_scope))) - 1)
                else:
##                    print('*** STANDARD GET ***')
                    current_scope.add(line)
##                    print('{} = dict()'.format(current_scope))
                    exec('self.dict{} = dict()'.format(current_scope))
                tab_depth = new_tab_depth
##                print('TAB_DEPTH:', tab_depth)
            else: #may freak out on blank lines with a different tab depth
                if new_tab_depth < tab_depth: #rarely occurs
##                    print('*** REDUCING ***')
                    current_scope.reduce(tab_depth - new_tab_depth)
##                print('*** KEY VALUE UPDATE ***')
                key, value = line.split('" "')
                key = key[1:]
                value = value[:-1]
##                print("self.dict{}['{}'] = '{}'".format(current_scope, key, value))
                exec('self.dict{}[key] = value'.format(current_scope))
    
        def export(self, outfile):
            print('Exporting ... ', end='')
            outfile.write('// This .vmf was generated by vmf_tool.py\n')
            outfile.write('// source: {}\n'.format(self.filename))
            outdict = self.dict
            #RECURSE THIS!
            for header in self.dict:
                if header.endswith('s'):
                    outfile.write(singularise(header) + '\n')
                else:
                    outfile.write(header + '\n')
                outfile.write('{\n')
                current_lump = outdict.pop(header)
                #while True: #or some kinf of loop
                    #recursively go deeper
                    #CAN WE USE A SCOPE CLASS?
                    #pop each value as you write
                    #deeper: tabs += 1
                    #shallower: tabs -= 1 (for each level risen)
                    #once a layer's keys are expended:
                    # -- tabs - 1
                    # -- write('}\n')
                    #some entries are lists, not dicts
                    #bottom layer is "key" "value"
                    # -- a dict containing strings
                    # -- however these may become lists of integers or dataclasses in future
                    # -- all layers above are dicts containing a mix of dicts & lists of dicts
                    # ---- or lists containing only dicts
                    # --> outfile.write('\t' * tabs + line + '\n')  
            print('Done!')

if __name__ == "__main__":  
    from time import time
    start = time()
    v = vmf(open('test.vmf')) #must contain I/O of some kind for this test
    print('{:.2f}ms'.format((time() - start) * 1000))
    ##rough VertexBuffer conversion
##    import itertools
##    all_solids = v.dict['world']['solids']
##    all_sides = [x['sides'] for x in all_solids]
##    all_sides = list(itertools.chain(*all_sides))
##    all_tris = [x['plane'] for x in all_sides]
##    all_tris = [x[1:-1].split(') (') for x in all_tris]
##    all_tris = [list(map(float, y.split())) for x in all_tris for y in x]
    #filter(lambda x: x['material'] != 'TOOLS/TOOLSNODRAW' and x['material'] != 'TOOLS/TOOLSSKYBOX', all_sides)
    #[x['classname'] for x in v.dict['entities']]
    all_ents_with_outputs = list(filter(lambda e: 'connections' in e.keys(), v.dict['entities']))
    all_connections = [e['connections'] for e in all_ents_with_outputs]
    #now add all referenced targetnames to list
    #and create a top-down map of these ents
