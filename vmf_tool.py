##TODO:
# write to file (export)
# setattr version & speed compare
# named tuple
# python 3.7 (f-strings & dataclasses)
# profiling (minimise redundant actions)
# entitiy I/O representation (html? html based editor?)
# .js conversion for web-editor
# -- does js have a faster importer? (builtins)
# .vmf diff
# -- export to vmf
# --- two visgroups, one for each map
# --- only changed brushes
# use } as an indication of a downshift
# -- some keys are downshifted (e.g. entity connections then origin)
# -- if you don't downshift you'll misplace your keys

##VMT_TOOL
# This almost works with .vmt but headers are occasionally in quotes
# Since .vmf is usually generated by a computer it can be more strict
# However with .vmt there are both quoted & non-quoted keys & classnames
# Tab-depth may be interchanged with spaces [line.replace('    ', '\t')]
# Water makes for the most complex .vmt(s) AFAIK

##QUESTIONS:
# what should be done before releasing this code publicly
# can this code be used for .bsp entities
# -- are bsp entities ever multi-dimensional?

def pluralise(word):
    if word.endswith('f'): # self -> selves
        return word[:-1] + 'ves'
    elif word.endswith('y'): # body -> bodies
        return word[:-1] + 'ies'
    else:
        return word + 's'

def singularise(word):
    if word.endswith('ves'): # self <- selves
        return word[:-3] + 'f'
    elif word.endswith('ies'): # body <- bodies
        return word[:-3] + 's'
    elif word.endswith('s'):
        return word[:-1]
    else: # assume word is already singular
        return word

class scope:
    """Handles a string used to index a multi-dimensional dictionary, correctly reducing nested lists of dictionaries"""
    def __init__(self, strings=[]):
        self.strings = strings

    def __repr__(self):
        scope_string = ''
        for string in self.strings:
            if isinstance(string, str):
                scope_string += "['" + string + "']"
            elif isinstance(string, int):
                scope_string += "[" + str(string) + "]"
        return scope_string

    def add(self, new):
        self.strings.append(new)

    def reduce(self, count):
        for i in range(count):
            try:
                if isinstance(self.strings[-1], int):
                    self.strings = self.strings[:-2]
                else:
                    self.strings = self.strings[:-1]
            except:
                break


class vmf:
    def __init__(self, file):
        self.filename = file.name
        whole_file = file.read().replace('{', '').replace('}', '')        
        self.dict = {}
        current_scope = scope()
        line_no = 1
        tab_depth = -1
        for line in whole_file.split('\n'):
##            print(line_no, line)
            line_no +=1
##            if line_no > 420:
##                raise RuntimeError()
            new_tab_depth = line.count('\t')
            line = line.lstrip('\t')
            if line == '':
                pass
            elif '"' not in line:
                if new_tab_depth == 0:
##                    print('*** RESETTING SCOPE ***')
                    current_scope = scope([]) # blank scope() doesn't work, but why?
                if new_tab_depth <= tab_depth:
##                    print('*** DOWNSHIFTING ***')
##                    print(current_scope, '>>>', end=' ')
                    current_scope.reduce(tab_depth - new_tab_depth + 1)
##                    print(current_scope)
                current_keys = eval('self.dict{}.keys()'.format(current_scope))
                lines = pluralise(line)
                if line in current_keys:
##                    print('*** PLURAL SHIFT ***')
##                    print("{}['{}'] = [{}['{}']]".format(current_scope, lines, current_scope, line))
                    exec('self.dict{}[lines] = [self.dict{}[line]]'.format(current_scope, current_scope))
##                    print('self.dict{}.pop({})'.format(current_scope, line))
                    exec('self.dict{}.pop(line)'.format(current_scope))
##                    print("{}['{}'].append(dict())".format(current_scope, lines))
                    exec('self.dict{}[lines].append(dict())'.format(current_scope))
                    current_scope = scope([*current_scope.strings, lines, 1])
##                    print(current_scope)
##                    print(current_keys)
                elif lines in current_keys:
##                    print('*** PLURAL APPEND ***')
                    current_scope.add(lines)
##                    print("{}.append(dict())".format(current_scope))
                    exec("self.dict{}.append(dict())".format(current_scope))
                    current_scope.add(len(eval('self.dict{}'.format(current_scope))) - 1)
                else:
##                    print('*** STANDARD GET ***')
                    current_scope.add(line)
##                    print('{} = dict()'.format(current_scope))
                    exec('self.dict{} = dict()'.format(current_scope))
                tab_depth = new_tab_depth
##                print('TAB_DEPTH:', tab_depth)
            else: #may freak out on blank lines with a different tab depth
                if new_tab_depth < tab_depth: #rarely occurs
##                    print('*** REDUCING ***')
                    current_scope.reduce(tab_depth - new_tab_depth)
##                print('*** KEY VALUE UPDATE ***')
                key, value = line.split('" "')
                key = key[1:]
                value = value[:-1]
##                print("self.dict{}['{}'] = '{}'".format(current_scope, key, value))
                exec('self.dict{}[key] = value'.format(current_scope))

if __name__ == "__main__":
##    v = vmf(open('fusion_base.vmf'))
    from time import time
    start = time()
    v = vmf(open('F:/Modding/tf2 maps/koth_campania_dev/koth_campania_af.vmf'))
    print('{:.2f}ms'.format((time() - start) * 1000))
##    import itertools
##    all_solids = v.dict['world']['solids']
##    all_sides = [x['sides'] for x in all_solids]
##    all_sides = list(itertools.chain(*all_sides))
##    all_tris = [x['plane'] for x in all_sides]
##    all_tris = [x[1:-1].split(') (') for x in all_tris]
##    all_tris = [list(map(float, y.split())) for x in all_tris for y in x]
    #filter(lambda x: x['material'] != 'TOOLS/TOOLSNODRAW' and x['material'] != 'TOOLS/TOOLSSKYBOX', all_sides)
    #[x['classname'] for x in v.dict['entities']]
    all_ents_with_outputs = list(filter(lambda e: 'connections' in e.keys(), v.dict['entities']))
    all_connections = [e['connections'] for e in all_ents_with_outputs]
    #now add all referenced targetnames to list
    #and create a top-down map of these ents
