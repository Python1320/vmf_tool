##TODO:
#################################### write to file (export)
# setattr version & speed compare
# -- for key in self.dict.keys():
# --    setattr(self, key, self.dict[key])
# -- del self.dict
# compare named tuple performance
# python 3.7 (dataclasses)
# entitiy I/O visualisation (html? html based editor?)
# .js version for web-editor
# -- does js have a faster importer? (builtins)
# .vmf diff (utilise difflib)
# -- export to vmf
# --- two visgroups, one for each map
# --- only diffent solids / entities
# locate overlapping brushes (doubles most important)

##VMT_TOOL
# This almost works with .vmt but headers are occasionally in quotes
# Since .vmf is usually generated by a computer it can be more strict
# However with .vmt there are both quoted & non-quoted keys & classnames
# Tab-depth may be interchanged with spaces [line.replace('    ', '\t')]
# Water makes for the most complex .vmt(s) AFAIK

##QUESTIONS:
# can this code be used for .bsp entitiy lumps?
# -- are bsp entities ever multi-dimensional?

def pluralise(word):
    if word.endswith('f'): # self -> selves
        return word[:-1] + 'ves'
    elif word.endswith('y'): # body -> bodies
        return word[:-1] + 'ies'
    else:
        return word + 's'

class scope:
    """Handles a string used to index a multi-dimensional dictionary, correctly reducing nested lists of dictionaries"""
    def __init__(self, strings=[]):
        self.strings = strings
                           
    def __len__(self):
        """ returns depth, ignoring plural indexes"""
        return len(filter(lambda x: isinstance(x, str), self.strings))

    def __repr__(self):
        scope_string = ''
        for string in self.strings:
            if isinstance(string, str):
                scope_string += "['" + string + "']"
            elif isinstance(string, int):
                scope_string += "[" + str(string) + "]"
        return scope_string

    def add(self, new):
        self.strings.append(new)

    def reduce(self, count):
        for i in range(count):
            try:
                if isinstance(self.strings[-1], int):
                    self.strings = self.strings[:-2]
                else:
                    self.strings = self.strings[:-1]
            except:
                break

def singularise(word):
    if word.endswith('ves'): # self <- selves
        return word[:-3] + 'f'
    elif word.endswith('ies'): # body <- bodies
        return word[:-3] + 's'
    elif word.endswith('s'): # horse <- horses
        return word[:-1]
    else: # assume word is already singular
        return word

def yield_dict(d, depth=0):
    keys = d.keys()
    for key in keys:
        value = d[key]
        if isinstance(value, dict):
            yield '\t' * depth + key + '\n' + '\t' * depth + '{\n'
            for output in yield_dict(value, depth + 1):
                yield output
        elif isinstance(value, list):
            key = singularise(key)
            for item in value:
                yield '\t' * depth + key + '\n' + '\t' * depth + '{\n'
                for output in yield_dict(item, depth + 1):
                    yield output
        else:
            yield '\t' * depth + f'"{key}" "{value}"' + '\n'
    if depth > 0:
        yield '\t' * (depth - 1) + '}\n'

class vmf:
    def __init__(self, file):
        self.filename = file.name
        self.dict = {}
        current_scope = scope()
        line_no = 1
        tab_depth = -1
        for line in file.readlines():
##            print(line_no, line)
            line_no +=1
##            if line_no > 420:
##                raise RuntimeError()
            new_tab_depth = line.count('\t')
            line = line.lstrip('\t')
            line = line.rstrip('\n')
            if line == '' or line == '{' or line == '}':
                pass
##          elif line == '}':
##              print('*** DOWNSHIFTING ***')
##              print(current_scope, '>>>', end=' ')
##              current_scope.reduce(tab_depth - new_tab_depth + 1)
##              print(current_scope)
            elif '"' not in line:
                if new_tab_depth == 0:
##                    print('*** RESETTING SCOPE ***')
                    current_scope = scope([]) # blank scope() doesn't work, but why?
                if new_tab_depth <= tab_depth:
##                    print('*** DOWNSHIFTING ***')
##                    print(current_scope, '>>>', end=' ')
                    current_scope.reduce(tab_depth - new_tab_depth + 1)
##                    print(current_scope)
                current_keys = eval(f'self.dict{current_scope}.keys()')
                lines = pluralise(line)
                if line in current_keys:
##                    print('*** PLURAL SHIFT ***')
##                    print(f"{current_scope}['{lines}'] = [{current_scope}['{line}']]")
                    exec(f'self.dict{current_scope}[lines] = [self.dict{current_scope}[line]]')
##                    print(f'self.dict{current_scope}.pop({line})')
                    exec(f'self.dict{current_scope}.pop(line)')
##                    print(f"{current_scope}['{lines}'].append(dict())")
                    exec(f'self.dict{current_scope}[lines].append(dict())')
                    current_scope = scope([*current_scope.strings, lines, 1])
##                    print(current_scope)
##                    print(current_keys)
                elif lines in current_keys:
##                    print('*** PLURAL APPEND ***')
                    current_scope.add(lines)
##                    print(f"{current_scope}.append(dict())")
                    exec(f"self.dict{current_scope}.append(dict())")
                    current_scope.add(len(eval(f'self.dict{current_scope}')) - 1)
                else:
##                    print('*** STANDARD GET ***')
                    current_scope.add(line)
##                    print(f'{current_scope} = dict()')
                    exec(f'self.dict{current_scope} = dict()')
                tab_depth = new_tab_depth
##                print('TAB_DEPTH:', tab_depth)
            else: #may freak out on blank lines with a different tab depth
                if new_tab_depth < tab_depth: #rarely occurs
##                    print('*** REDUCING ***')
                    current_scope.reduce(tab_depth - new_tab_depth)
##                print('*** KEY VALUE UPDATE ***')
                key, value = line.split('" "')
                key = key[1:]
                value = value[:-1]
##                print(f"self.dict{current_scope}['{key}'] = '{value}'")
                exec(f'self.dict{current_scope}[key] = value')
    
        def export(self, outfile):
            """don't forget to close the file afterwards"""
            print('Exporting ... ', end='')
            #comments are discarded after saving the .vmf in hammer
            outfile.write('// This .vmf was generated by vmf_tool.py\n')
            outfile.write(f'// source: {self.filename}\n')
            for line in yield_dict(self.dict):
                outfile.write(line)
            print('Done!')

if __name__ == "__main__":  
    from time import time
    start = time()
##    v = vmf(open('test.vmf'))
##    v = vmf(open('E:/Steam/SteamApps/common/sourcesdk_content/tf/mapsrc/sdk_cp_gravelpit.vmf'))
    #^ known to have invalid solids
    v = vmf(open('F:/Code/python/import_bsp/bsp_import_props.vmf'))
    print(f'{(time() - start) * 1000:.2f}ms')

##    import vector
##    import itertools
##    for solid_no, solid in enumerate(v.dict['world']['solids']):
##        planes = [x['plane'][1:-1].split(') (') for x in solid['sides']]
##        planes = [[y.split() for y in x] for x in planes]
##
##        normals = []
##        verts = []
##        for i, plane in enumerate(planes):
##            plane = [[*map(float, x)] for x in plane]
##            planes[i] = [*map(vector.vec3, plane)]
##            A, B, C = map(vector.vec3, plane)
##            normals.append(((A - B) * (C - B)).normalise())
##            verts.append(A)
##            verts.append(B)
##            verts.append(C)
##
##        center = sum(verts, vector.vec3()) / len(verts)
##
##        for i, normal in enumerate(normals):
##            normal2 = (sum(planes[i], vector.vec3()) / 3) - center
##            dot = vector.dot(normal, normal2)
##            if dot < 0:
##                print(solid['sides'][i]['plane'] + f' {dot:.2f}')
            
    ## rough VertexBuffer conversion
##    import itertools
##    all_solids = v.dict['world']['solids']
##    all_sides = [x['sides'] for x in all_solids]
##    all_sides = list(itertools.chain(*all_sides))
##    all_tris = [x['plane'] for x in all_sides]
##    all_tris = [x[1:-1].split(') (') for x in all_tris]
##    all_tris = [list(map(float, y.split())) for x in all_tris for y in x]

    #filter(lambda x: x['material'] != 'TOOLS/TOOLSNODRAW' and x['material'] != 'TOOLS/TOOLSSKYBOX', all_sides)
    #[x['classname'] for x in v.dict['entities']]
##    all_ents_with_outputs = list(filter(lambda e: 'connections' in e.keys(), v.dict['entities']))
##    all_connections = [e['connections'] for e in all_ents_with_outputs]
    #now add all referenced targetnames to list
    #and create a top-down map of these ents
